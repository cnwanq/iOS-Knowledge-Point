# 建议1：视OC为一门动态语言
OC作为一门动态开发语言，会尽可能地编译和链接时要做的事情推迟到运行时。
要想理解“Objective-C是一门动态开发语言”，就不得不理解开发语言的三个不同层次。
1. 传统的面向过程的语言开发。
2. 改进的开发面向对象的语言。
3. 动态开发语言。

* Objective-C是动态语言，C++是静态语言
* 静态语言执行效率和安全性要比动态语言高，但其简便性没有动态语言高
* 运行时环境可处理弱类型、函数存在检查工作，会检测注册列表里是否存在对应的函数，类型是否正确，最后确定正确的函数地址，再进行保存寄存器状态、压栈、函数调用等实际操作，确保了Objective-C的灵活性


# 建议2：在头文件中尽量减少其他头文件的引用
* 在头文件中，关键字`@class`，只是为了在头文件中引用这个类，把这个类作为一个类型来用，这就要求引用的 头文件名与类的名称一致
* 在头文件中使用`@class`，在源文件中使用`#import`，不但可以减少不必要的编译时间，降低类之间的耦合度，而且还可以避免循环引用
* 在设计类时，尽量多采用协议，避免`#import`过多，引进不必要的部分
* 如果头文件中有多个类的定义，尽量采用模块方式，只针对性引进所需要的类


# 建议3：尽量使用const、enum来替换预处理#define
`#define`定义了一个宏，在编译开始之前就会被替换。`const`只是对变量进行修饰，当试图去修改该变量时，编译器会报错。

* 尽量避免使用`#define`预处理命令。`#define`预处理命令不包含任何的类型信息，仅仅是编译前做替换操作。它们的重复定义时不会发出警告，容易在整个程序中产生不一致的值
* 在源文件中定义的`static const`类型常量因为无须全局引用，所以它们的名字不需要包含命名空间
* 在头文件中定义的全局引用的常量，需要关联定义在源文件中的部分。因为需要被全局引用，所以它们的名字需要包含命名空间，通常使用它们的类名作为命名前缀
* 尽量用`NS_ENUM`和`NS_OPTIONS`宏来实现枚举


# 建议4：优先使用对象字面量语法而非等效方法
* 尽量使用对象字面量语法来创建字符串、数字、数组和字典等，使用它比使用以前的常规对象创建方法语法更为精简，同事可以避免一些常见的陷进
* 对象字面量语法特性是完全向下兼容，使用新特性编写出来的代码，经过编译后形成的二进制程序可以运行在之前发布的任何OS中
* 在数字和字典中，要使用关键字和索引做下标来获取数据
* 使用对象字面量语法时，容器类的不可是nil，否则运行时将会抛出异常


# 建议5：处理隐藏的返回类型，优先选择实例类型而非id
* instancetype仅仅用来作为Objective-C方法的返回类型
* 使用instancetype可避免隐式转换id而造成的欺骗性编译无误通过的现象，防止程序正式运行时出现崩溃现象，可以大大改善Objective-C代码的类型安全
* 在某一个特性区域，instancetype可以替代id，并非所有区域都可以替换id


# 建议6：尽量使用模块方式与多类建立复合关系
* `#include`和`#import`，其根本就是简单的复制、粘贴，将目标.h文件中的内容一字不落地复制到当前文件中，后者可以避免多次的重复引用
* 以预编译头文件的方式，虽可缩短编译时间，但其维护棘手，不利于广泛应用
* 模块功能，其引用不仅仅表现于编译的速度加快，同时在链接框架等方面也非常好用
* 启动模块功能后，编译器会隐式地把所有的`#import`都转换成`@import`


# 建议7：理解Objective-C++中的有所为而有所不为
* C++和Objcetive-C在定义结构上一样，但是后者的继承是封闭的
* Objcetive-C接口中的定义的C++类是全局范围的，而不是Objcetive-C累的内嵌类
* C++和Objcetive-C的对象模型不能直接兼容。与Objcetive-C不同的是，C++对象是静态类型的，有运行时系统多态是特殊情况
* C++和Objcetive-C有词汇歧义和冲突
* C++和Objcetive-C两者功能上有限制。Objcetive C++没有为Objcetive-C类增加C++的功能，也没有为C++类增加Objcetive-C的功能


# 建议8：C语言与Objective-C语言的关系是充分而非必要条件
* C语言的基本语法在Objective-C语言中是可用的
* 与C语言相比，Objective-C语言又定义了新的基本数据类型，如BOOL
* Objective-C值对象比C类型变量具有封装常用操作的优势，单在数值计算中，使用C类型标量更为简洁


# 建议9：高度警惕空指针和野指针的袭击
没有存储任何内存地址的指针就称为空指针。空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
野指针不是NULL指针，而是指向“垃圾”内存的指针。野指针是非常危险的。

* 空指针（NULL指针），是指没有存储任何内存地址的指针。野指针，是指向“垃圾内存”的指针。
* 利用野指针发消息是很危险的，会报错。也就是说，如果一个对象已经被回收了，就不要再去操作他，不要再尝试给它发消息。
* 利用空指针发消息是没有任何问题的，也就是说代码是没有错误的。


# 建议10：在64位环境下尽可能利用标记指针
* 利用标记指针，可以在指针地址中保存或附加更多的信息
* 医用标记指针处理NSNumber，直接可以把实际的值保存到指针中，而无须再去访问堆中的数据，可提高内存访问速度和整体运算速度
* 在32位和64位的环境下，isa指针会产生不同的变化。在64位环境下，标记指针会加快isa指针的处理效率


# 建议11：谨记兼容32位和64位环境下代码编写事项
* 不要将长整型数据赋予整型
* 利用NSInteger来处理32位和64位之间的转换
* 创建数据结构要注意固定大小和对齐


# 建议12：清除常量字符串和一般字符串的区别
* 由于编译器的优化，相同内容的常量字符串的地址值是完全相同的
* 如果使用常量字符串来初始化一个字符串，那么这个字符串也将是相同的常量
* 对常量字符串永远不要release


# 建议13：在访问集合时要有效考虑使用快速枚举
* 使用快速枚举，要尽可能使用枚举新的写法
* 和直接使用NSEnumerator相比，使用快速枚举可以更有效率，表达式更简洁
* 使用快速枚举，枚举更安全，因为枚举会监控枚举对象的变化，如果在枚举的过程中枚举对象发生变化会抛出一个异常
* 多个枚举可以同时进行，因为在循环中被循环对象是禁止修改的。另外，同其他的循环一样，可以适用break来停止循环或者适用continue来略过当次循环而进行到下一元素


# 建议14：有序对象适宜存于数组，而无须对象适宜存于集合
* 数组可维持持续性，故适宜存储有序的对象，但每一项必须是Objective-C对象。集合不维持秩序，故适宜存储无序对象
* 同一数组可以保存不同的对象，但不能村粗float、int、double等基本类型和nil，否则存储基本类型都会被设置为0，不能存储nil是因为数组必须用nil来结尾
* 快速枚举是访问数组中的对象的一种比较快的方法
* 使用NSArray和NSDictionary类可以直接将其内容写入磁盘进行持久化


# 建议15：存在公共键时，字典是在对象之间传递信息的绝佳方式
* 字典不仅可以作为无序对象的集合，还可以作为有序对象的集合
* 字典可作为有序对象的集合，主要依赖于键值可采用有序
* 存在公共键时，字典实在对象之间传递各种信息的绝佳方式


# 建议16：明智而审慎地使用BOOL类型
* 整型转为BOOL型，使用三元操作符，以保证返回YES或NO值
* 整型转换为BOOL型的时候要避免直接和YES做比较
* BOOL值进行逻辑原酸不但有效，而且还可以确保返回值安全地转为BOOL型，无须三元操作符


# 建议17：理解内存和Objective-C内存管理规则
* 内存可看作为内存控制器与CPU之间的桥梁，内存也就是相当于“仓库”。如何合理利用内存是写好一个高性能应用程序的关键所在。一个应用程序过量的占用内存，势必会影响到其他内存的生存
* Objective-C内存管理模式基于对象的所有权上。任何对象都会被一个或多个使用者引用，只要对象还有一个使用者，改对象就应该继续存在。如果一个对象没有使用者了，系统将自动销毁它
* 对象所有权策略是基于引用计数实现的，每一个对象有一个retaincount变量。创建对象后，它的reatiancount是1，retain之后，retainCount+1; release之后，retaincount-1; 对象的retaincount减少到0时，对象呗销毁


# 建议18：内存管理讲究好借好还，再借不难
* 在Objective-C中，释放对象应有效使用release而非autorelease，但在不适合立即回收对象的情况下，应有效使用autorelease
* 当返回一个新创建对象时，应该使用autorelease而不是release来释放所有权
* 对于拥有alloc返回的对象而言，失去释放所有权之前，应先失去对该对象的引用


# 建议19：区别开alloc、init、retain、release和dealloc之间的差异
1. alloc是创建变量，dealloc是释放变量，retain是计数加1，release是计数减1
2. 分配过程（alloc和init）不仅进行对象的内存分配，还要对它的isa实例变量和保持数初始化
3. 对象赋值时尽量采用autorelease而不是retain模式


# 建议20：优先选用存取方法来建华内存管理
* 使用存取方法管理内存，可大大降低管理方面出现的问题
* 在代码中，管理实例变量尽可能避免全部使用retain和release，降低错误的发生概率
* 在init方法和dealloc两处地方，不要使用存取方法来设置实例变量
* 实现方法的重置。有两种选择，一种是使用简便构造函数创建一个新的NSNumber对象，因此没有必要发送任何retain或release消息；另一种使用alloc创建NSNumber实例，要相应地使用release。请注意，两种方法都是用了类的set存取方法


# 建议21：对象销毁或者被移除一定考虑所有权的释放
* 从集合中移除对象，集合要释放对被移除对象的所有权
* 防止出现父对象被释放前而子对象没有被释放
* 释放对象前，要确保其他对象对该对象的所有权已经释放
* 在Objective-C中，是否负责对象的释放，需要看如何获取的对象，既要看对象的所有权策略


# 建议22：明智而审慎地使用dealloc
* 任何时候，都不要直接调用另一个对象的dealloc方法
* 不许在dealloc的最后一行调用父类的dealloc
* 不要尝试管理系统资源。应用程序终止时，对象的dealloc可能不会被调用。因为进程的内存是自动清除退出，让操作系统清理资源比调用所有的内存管理方法更有效率

