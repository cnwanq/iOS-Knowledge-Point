# 建议1：视OC为一门动态语言
OC作为一门动态开发语言，会尽可能地编译和链接时要做的事情推迟到运行时。
要想理解“Objective-C是一门动态开发语言”，就不得不理解开发语言的三个不同层次。
1. 传统的面向过程的语言开发。
2. 改进的开发面向对象的语言。
3. 动态开发语言。

* Objective-C是动态语言，C++是静态语言
* 静态语言执行效率和安全性要比动态语言高，但其简便性没有动态语言高
* 运行时环境可处理弱类型、函数存在检查工作，会检测注册列表里是否存在对应的函数，类型是否正确，最后确定正确的函数地址，再进行保存寄存器状态、压栈、函数调用等实际操作，确保了Objective-C的灵活性


# 建议2：在头文件中尽量减少其他头文件的引用
* 在头文件中，关键字`@class`，只是为了在头文件中引用这个类，把这个类作为一个类型来用，这就要求引用的 头文件名与类的名称一致
* 在头文件中使用`@class`，在源文件中使用`#import`，不但可以减少不必要的编译时间，降低类之间的耦合度，而且还可以避免循环引用
* 在设计类时，尽量多采用协议，避免`#import`过多，引进不必要的部分
* 如果头文件中有多个类的定义，尽量采用模块方式，只针对性引进所需要的类


# 建议3：尽量使用const、enum来替换预处理#define
`#define`定义了一个宏，在编译开始之前就会被替换。`const`只是对变量进行修饰，当试图去修改该变量时，编译器会报错。

* 尽量避免使用`#define`预处理命令。`#define`预处理命令不包含任何的类型信息，仅仅是编译前做替换操作。它们的重复定义时不会发出警告，容易在整个程序中产生不一致的值
* 在源文件中定义的`static const`类型常量因为无须全局引用，所以它们的名字不需要包含命名空间
* 在头文件中定义的全局引用的常量，需要关联定义在源文件中的部分。因为需要被全局引用，所以它们的名字需要包含命名空间，通常使用它们的类名作为命名前缀
* 尽量用`NS_ENUM`和`NS_OPTIONS`宏来实现枚举


# 建议4：优先使用对象字面量语法而非等效方法
* 尽量使用对象字面量语法来创建字符串、数字、数组和字典等，使用它比使用以前的常规对象创建方法语法更为精简，同事可以避免一些常见的陷进
* 对象字面量语法特性是完全向下兼容，使用新特性编写出来的代码，经过编译后形成的二进制程序可以运行在之前发布的任何OS中
* 在数字和字典中，要使用关键字和索引做下标来获取数据
* 使用对象字面量语法时，容器类的不可是nil，否则运行时将会抛出异常


# 建议5：处理隐藏的返回类型，优先选择实例类型而非id
* instancetype仅仅用来作为Objective-C方法的返回类型
* 使用instancetype可避免隐式转换id而造成的欺骗性编译无误通过的现象，防止程序正式运行时出现崩溃现象，可以大大改善Objective-C代码的类型安全
* 在某一个特性区域，instancetype可以替代id，并非所有区域都可以替换id


# 建议6：尽量使用模块方式与多类建立复合关系
* `#include`和`#import`，其根本就是简单的复制、粘贴，将目标.h文件中的内容一字不落地复制到当前文件中，后者可以避免多次的重复引用
* 以预编译头文件的方式，虽可缩短编译时间，但其维护棘手，不利于广泛应用
* 模块功能，其引用不仅仅表现于编译的速度加快，同时在链接框架等方面也非常好用
* 启动模块功能后，编译器会隐式地把所有的`#import`都转换成`@import`


# 建议7：理解Objective-C++中的有所为而有所不为
* C++和Objcetive-C在定义结构上一样，但是后者的继承是封闭的
* Objcetive-C接口中的定义的C++类是全局范围的，而不是Objcetive-C累的内嵌类
* C++和Objcetive-C的对象模型不能直接兼容。与Objcetive-C不同的是，C++对象是静态类型的，有运行时系统多态是特殊情况
* C++和Objcetive-C有词汇歧义和冲突
* C++和Objcetive-C两者功能上有限制。Objcetive C++没有为Objcetive-C类增加C++的功能，也没有为C++类增加Objcetive-C的功能


# 建议8：C语言与Objective-C语言的关系是充分而非必要条件
* C语言的基本语法在Objective-C语言中是可用的
* 与C语言相比，Objective-C语言又定义了新的基本数据类型，如BOOL
* Objective-C值对象比C类型变量具有封装常用操作的优势，单在数值计算中，使用C类型标量更为简洁


# 建议9：高度警惕空指针和野指针的袭击
没有存储任何内存地址的指针就称为空指针。空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
野指针不是NULL指针，而是指向“垃圾”内存的指针。野指针是非常危险的。

* 空指针（NULL指针），是指没有存储任何内存地址的指针。野指针，是指向“垃圾内存”的指针。
* 利用野指针发消息是很危险的，会报错。也就是说，如果一个对象已经被回收了，就不要再去操作他，不要再尝试给它发消息。
* 利用空指针发消息是没有任何问题的，也就是说代码是没有错误的。


# 建议10：在64位环境下尽可能利用标记指针
* 利用标记指针，可以在指针地址中保存或附加更多的信息
* 医用标记指针处理NSNumber，直接可以把实际的值保存到指针中，而无须再去访问堆中的数据，可提高内存访问速度和整体运算速度
* 在32位和64位的环境下，isa指针会产生不同的变化。在64位环境下，标记指针会加快isa指针的处理效率


# 建议11：谨记兼容32位和64位环境下代码编写事项
* 不要将长整型数据赋予整型
* 利用NSInteger来处理32位和64位之间的转换
* 创建数据结构要注意固定大小和对齐


# 建议12：清除常量字符串和一般字符串的区别
* 由于编译器的优化，相同内容的常量字符串的地址值是完全相同的
* 如果使用常量字符串来初始化一个字符串，那么这个字符串也将是相同的常量
* 对常量字符串永远不要release


# 建议13：在访问集合时要有效考虑使用快速枚举
* 使用快速枚举，要尽可能使用枚举新的写法
* 和直接使用NSEnumerator相比，使用快速枚举可以更有效率，表达式更简洁
* 使用快速枚举，枚举更安全，因为枚举会监控枚举对象的变化，如果在枚举的过程中枚举对象发生变化会抛出一个异常
* 多个枚举可以同时进行，因为在循环中被循环对象是禁止修改的。另外，同其他的循环一样，可以适用break来停止循环或者适用continue来略过当次循环而进行到下一元素


# 建议14：有序对象适宜存于数组，而无须对象适宜存于集合
* 数组可维持持续性，故适宜存储有序的对象，但每一项必须是Objective-C对象。集合不维持秩序，故适宜存储无序对象
* 同一数组可以保存不同的对象，但不能村粗float、int、double等基本类型和nil，否则存储基本类型都会被设置为0，不能存储nil是因为数组必须用nil来结尾
* 快速枚举是访问数组中的对象的一种比较快的方法
* 使用NSArray和NSDictionary类可以直接将其内容写入磁盘进行持久化


# 建议15：存在公共键时，字典是在对象之间传递信息的绝佳方式
* 字典不仅可以作为无序对象的集合，还可以作为有序对象的集合
* 字典可作为有序对象的集合，主要依赖于键值可采用有序
* 存在公共键时，字典实在对象之间传递各种信息的绝佳方式


# 建议16：明智而审慎地使用BOOL类型
* 整型转为BOOL型，使用三元操作符，以保证返回YES或NO值
* 整型转换为BOOL型的时候要避免直接和YES做比较
* BOOL值进行逻辑原酸不但有效，而且还可以确保返回值安全地转为BOOL型，无须三元操作符


# 建议17：理解内存和Objective-C内存管理规则
* 内存可看作为内存控制器与CPU之间的桥梁，内存也就是相当于“仓库”。如何合理利用内存是写好一个高性能应用程序的关键所在。一个应用程序过量的占用内存，势必会影响到其他内存的生存
* Objective-C内存管理模式基于对象的所有权上。任何对象都会被一个或多个使用者引用，只要对象还有一个使用者，改对象就应该继续存在。如果一个对象没有使用者了，系统将自动销毁它
* 对象所有权策略是基于引用计数实现的，每一个对象有一个retaincount变量。创建对象后，它的reatiancount是1，retain之后，retainCount+1; release之后，retaincount-1; 对象的retaincount减少到0时，对象呗销毁


# 建议18：内存管理讲究好借好还，再借不难
* 在Objective-C中，释放对象应有效使用release而非autorelease，但在不适合立即回收对象的情况下，应有效使用autorelease
* 当返回一个新创建对象时，应该使用autorelease而不是release来释放所有权
* 对于拥有alloc返回的对象而言，失去释放所有权之前，应先失去对该对象的引用


# 建议19：区别开alloc、init、retain、release和dealloc之间的差异
1. alloc是创建变量，dealloc是释放变量，retain是计数加1，release是计数减1
2. 分配过程（alloc和init）不仅进行对象的内存分配，还要对它的isa实例变量和保持数初始化
3. 对象赋值时尽量采用autorelease而不是retain模式


# 建议20：优先选用存取方法来建华内存管理
* 使用存取方法管理内存，可大大降低管理方面出现的问题
* 在代码中，管理实例变量尽可能避免全部使用retain和release，降低错误的发生概率
* 在init方法和dealloc两处地方，不要使用存取方法来设置实例变量
* 实现方法的重置。有两种选择，一种是使用简便构造函数创建一个新的NSNumber对象，因此没有必要发送任何retain或release消息；另一种使用alloc创建NSNumber实例，要相应地使用release。请注意，两种方法都是用了类的set存取方法


# 建议21：对象销毁或者被移除一定考虑所有权的释放
* 从集合中移除对象，集合要释放对被移除对象的所有权
* 防止出现父对象被释放前而子对象没有被释放
* 释放对象前，要确保其他对象对该对象的所有权已经释放
* 在Objective-C中，是否负责对象的释放，需要看如何获取的对象，既要看对象的所有权策略


# 建议22：明智而审慎地使用dealloc
* 任何时候，都不要直接调用另一个对象的dealloc方法
* 不许在dealloc的最后一行调用父类的dealloc
* 不要尝试管理系统资源。应用程序终止时，对象的dealloc可能不会被调用。因为进程的内存是自动清除退出，让操作系统清理资源比调用所有的内存管理方法更有效率



# 建议23：编写代码要遵守Cocoa API约定
1. 返回对象的方法通常通过返回nil来表示创建失败或没有对象可以返回
    这种方法并不返回状态码。返回nil的约定通常用于表示运行时错误或其他非厉害的条件。Cocoa框架通过抛出例外（有顶级的例外处理代码处理），来处理诸如数组索引月结或不能识别方法选择器这样的错误。如果方法签名有要求的话，同时返回nil。
2. 某些可能返回nil的方法可以通过最后一个参数以引用的方式返回错误信息。
    对于执行失败的方法（也就是说方法返回nil），可以通过曹操返回的错误对象来确定错误的原因，或者将错误显示在对话框上。
3. 执行某些系统操作的方法通常返回一个Boolean值，以指示执行成功还是失败
4. Cocoa用空的容器对象来表示默认值或没有值---nil通常不是正当的对象参数
5. Cocoa框架要求在字典键、通知和异常名称，以及一些用字符串作为参数的方法上使用全局字符串常数，而不是一个字符串文字。
6. Cocoa框架在类型使用上是一致的，各组API之间可以进行较好的匹配

* 在API明明商，清楚是第一原则，而非简洁，切记要避免模棱两可的命名
* 在对函数或方法命名上，务必要使用动词，突显函数和方法的动性
* 在API名称上不要使用缩写，除非是众所周知的缩写
* 在对类名和类相关联的符号命名时，务必要使用前缀


# 建议24：洞悉实例变量
* 实例变量的命名规则是使用小写字符串，不包含标点符号和特殊字符。如果变量名称包含多个词，就直接把这些词连起来，且第二个及之后的词的首字母大写
* 只加入一些绝对必要的实例变量，否则容易造成大的开销。在可能的情况下，尽量从现有的实例变量中计算出一个关键值，而不是增加新的实例变量
* 永远不要将变量设置为@public，因为这违反了封装的原则
* 确保类基本属性对应的实例变量有存取方法


# 建议25：透彻了解属性的里里外外
* 属性的动态性定义，需要关键字@dynamic。属性动态性是相对于@synthesis来说的，不是由编译器自动生成setter或getter，而是在运行时动态添加的setter和getter
* 属性采用动态性，与采用静态性相比，可以简化代码的编写，便于代码的管理
* 默认情况下，可写属性使用的实例变量被称为_propertyName。如果要想使用的实例变量不同名，需要在实现中指示编译器合成的变量
* 利用类扩展可实现对属性的篡改


# 建议26：存取方法是良好的类接口必要组成部分
* 存取方法是通过对象属性的一道门槛，负责提供对象属性的访问通道，并强制对对象实例数据的封装，防止实例数据被破坏
* 方法返回的对象，需要保证对象在该作用域不被释放或修改
* 调用对象从某个方法接收到对象时，不应该对其进行释放，除非他先前进行显示的保持


# 建议27：明晓类公共领域的方法都是虚方法
* 在Objective-C中，所有的方法都是虚方法
* 实现纯虚方法依赖正式协议来实现
* 协议并不是真正的类，它只能声明方法，不能添加数据
* 非正式协议并不是真正的协议，它对代码没有约束力


# 建议28：初始化还是解码取决于是否支持归档还是解档
* 类的对象支持归档和解档，该类必须遵循NSCoding协议；必须实现对对象进行编码和解码的方法
* 类的初始化方法和initWithCoder:在角色上的并行性存在例外


# 建议29：利用键值机制访问类的私有成员变量和方法
* 在Objective-C中，类的成员变量或方法是没有绝对私有的，可以借助编译运行时机制，即瞎子摸黑机制来实现对它们的访问
* KVC和KVO在定制子类的设计时特别重要
* KVC、KVO和KVB都支持遍历
* KVC主要通过isa指针来实现其内部查找定位。KVO其设计基于设计模式中的观察者模式。KVB和KVO最明显的使用场景就是在一些界面实时显示很强的地方


# 建议30：浅复制适宜指针而深复制适宜数据
* 浅复制，是将原始对象的指针值复制到副本中，从而达到原始对象和副本共享引用数据的目的；深复制，是复制指针所引用的数据，并将其赋给副本的实例变量
* 一般情况下，可以被视为数据容器的指针型实例变量往往被深复制，而更复杂的实例变量则被浅复制
* 实例变量的set方法的实现要能够反映出需要使用的复制类型。如果相应的set方法复制了新的值，那么就应该深复制这个实例变量
* 如果实例变量的set方法只是简单地将新的值赋给实例变量，而没有复制或保留它，那么就应该浅复制这个实例变量


# 建议31：明智而审慎地使用NSCopying
* 基类没有实现NSCopying，那么子类的实现必须复制它所继承的实例变量，以及那些在类中声明的实例变量，最安全的方式是使用alloc、init和set方法
* 类继承了NSCopying的行为，并声明了额外的实例变量，那么也需要实现copyWithZone：
* 如果基类使用了或者有可能使用过NSCopyObject，那么必须使用有别于alloc和init函数的情况，用不用的方式处理实例变量


# 建议32：使用协议来实现匿名对象的提供
* 采用协议，可灵活实现。实现抽象不应该依赖于细节，而细节应该依赖于抽象，降低声明和实现的耦合度
* 设计程序采用协议，可减少继承类的复杂性


# 建议33：使用分类把类的实现拆分成不同的文件
* 利用类别机制，可将同一个类的实现，由一个常规的实现文件拆分成多个实现文件
* 把同一个类的实现文件拆分成多个实现文件，适合类的实现文件大多比较庞大
* 把同一个类的实现文件拆分成多个实现文件，拆分的标准多是以同类型或同业务类型等来作为参考


# 建议34：明智地使用内省可使程序更加高效和健壮
1. 评估继承关系
2. 方法实现和协议遵循
3. 对象的比较

* 内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息
* 内省有助于避免错误地进行消息派发、错误地假设对象相等，以及类似的问题
* NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别
* 在Cocoa框架的所有isEqualToType:方法中，nil都不是正当的参数，这些方法的实现在接收到nil参数时会抛出异常。然后为了向后兼容，Cocoa框架中的isEqual:方法可以接受nil值，在这种情况下返回NO


# 建议35：尽量使用不可变性对象而非可变性对象
* 尽量不要把可变对象存储到集合对象中，否则容易导致存储的可变对象呗破坏或变成无效
* 在开销上，可变对象比不可变对象要大，因为可变对象必须动态管理一个可变的辅助存储————在必要时分配或解除分配内存块，所以比相应的不可变版本效率低
* 不能确定对象是否可变，则将她当成不可变处理


# 建议36：利用复合能巧妙地把两个类或两个对象融合
* 在OOP编程中有两个技术用于描述类与类对象或对象与对象之间的关系：一个是继承，另一个是复合
* 复合是通过类中声明一个指向另一个类对象的指针作为实例变量，从而将这个两个类进行复合
* 使用new创建对象的时候，实际发生了两个步骤：第一个步骤，为对象分配内存，也就是说对象获得存储其实例变量的内存块；第二步，就是自动调用init方法，初始化对象使其处于可用状态。没有被初始化的指针都是nil
* 在Objective-C中所有对象之间的交互都是通过指针实现的


# 建议37：使用类扩展来隐藏实现的细节
* 类扩展，从一定程度而言，可称为匿名类别
* 利用类扩展隐藏私用信息
* 如果打算将私有的方法或属性用来选择相关的类，可以在单独的头文件中声明类扩展， 并把其导入到需要它的源文件中


# 建议38：使用内联块应注意避免循环引用
* 在内联块中能直接引用self,但是注意避免导致循环引用
* 避免由于在内联块中直接引用self导致的循环引用，较好的方式，引进弱引用来预防
* 在非内联块不能直接访问self，只能通过将self当作参数传递到块中才能使用，并且此时的self只能通过setter或getter方法访问其属性，不能使用句点式方法



# 建议39：利用类别把方法添加到现有的类


# 建议40：通过强弱引用来管理对象的所有权
* `__weak`对面是`__strong`。不必明确指定



