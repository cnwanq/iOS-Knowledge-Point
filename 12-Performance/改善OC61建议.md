# 建议1：视OC为一门动态语言
OC作为一门动态开发语言，会尽可能地编译和链接时要做的事情推迟到运行时。
要想理解“Objective-C是一门动态开发语言”，就不得不理解开发语言的三个不同层次。
1. 传统的面向过程的语言开发。
2. 改进的开发面向对象的语言。
3. 动态开发语言。

* Objective-C是动态语言，C++是静态语言
* 静态语言执行效率和安全性要比动态语言高，但其简便性没有动态语言高
* 运行时环境可处理弱类型、函数存在检查工作，会检测注册列表里是否存在对应的函数，类型是否正确，最后确定正确的函数地址，再进行保存寄存器状态、压栈、函数调用等实际操作，确保了Objective-C的灵活性


# 建议2：在头文件中尽量减少其他头文件的引用
* 在头文件中，关键字`@class`，只是为了在头文件中引用这个类，把这个类作为一个类型来用，这就要求引用的 头文件名与类的名称一致
* 在头文件中使用`@class`，在源文件中使用`#import`，不但可以减少不必要的编译时间，降低类之间的耦合度，而且还可以避免循环引用
* 在设计类时，尽量多采用协议，避免`#import`过多，引进不必要的部分
* 如果头文件中有多个类的定义，尽量采用模块方式，只针对性引进所需要的类


# 建议3：尽量使用const、enum来替换预处理#define
`#define`定义了一个宏，在编译开始之前就会被替换。`const`只是对变量进行修饰，当试图去修改该变量时，编译器会报错。

* 尽量避免使用`#define`预处理命令。`#define`预处理命令不包含任何的类型信息，仅仅是编译前做替换操作。它们的重复定义时不会发出警告，容易在整个程序中产生不一致的值
* 在源文件中定义的`static const`类型常量因为无须全局引用，所以它们的名字不需要包含命名空间
* 在头文件中定义的全局引用的常量，需要关联定义在源文件中的部分。因为需要被全局引用，所以它们的名字需要包含命名空间，通常使用它们的类名作为命名前缀
* 尽量用`NS_ENUM`和`NS_OPTIONS`宏来实现枚举


# 建议4：优先使用对象字面量语法而非等效方法
* 尽量使用对象字面量语法来创建字符串、数字、数组和字典等，使用它比使用以前的常规对象创建方法语法更为精简，同事可以避免一些常见的陷进
* 对象字面量语法特性是完全向下兼容，使用新特性编写出来的代码，经过编译后形成的二进制程序可以运行在之前发布的任何OS中
* 在数字和字典中，要使用关键字和索引做下标来获取数据
* 使用对象字面量语法时，容器类的不可是nil，否则运行时将会抛出异常


# 建议5：处理隐藏的返回类型，优先选择实例类型而非id
* instancetype仅仅用来作为Objective-C方法的返回类型
* 使用instancetype可避免隐式转换id而造成的欺骗性编译无误通过的现象，防止程序正式运行时出现崩溃现象，可以大大改善Objective-C代码的类型安全
* 在某一个特性区域，instancetype可以替代id，并非所有区域都可以替换id


# 建议6：尽量使用模块方式与多类建立复合关系
* `#include`和`#import`，其根本就是简单的复制、粘贴，将目标.h文件中的内容一字不落地复制到当前文件中，后者可以避免多次的重复引用
* 以预编译头文件的方式，虽可缩短编译时间，但其维护棘手，不利于广泛应用
* 模块功能，其引用不仅仅表现于编译的速度加快，同时在链接框架等方面也非常好用
* 启动模块功能后，编译器会隐式地把所有的`#import`都转换成`@import`


# 建议7：理解Objective-C++中的有所为而有所不为
* C++和Objcetive-C在定义结构上一样，但是后者的继承是封闭的
* Objcetive-C接口中的定义的C++类是全局范围的，而不是Objcetive-C累的内嵌类
* C++和Objcetive-C的对象模型不能直接兼容。与Objcetive-C不同的是，C++对象是静态类型的，有运行时系统多态是特殊情况
* C++和Objcetive-C有词汇歧义和冲突
* C++和Objcetive-C两者功能上有限制。Objcetive C++没有为Objcetive-C类增加C++的功能，也没有为C++类增加Objcetive-C的功能


# 建议8：C语言与Objective-C语言的关系是充分而非必要条件
* C语言的基本语法在Objective-C语言中是可用的
* 与C语言相比，Objective-C语言又定义了新的基本数据类型，如BOOL
* Objective-C值对象比C类型变量具有封装常用操作的优势，单在数值计算中，使用C类型标量更为简洁


# 建议9：高度警惕空指针和野指针的袭击
没有存储任何内存地址的指针就称为空指针。空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。
野指针不是NULL指针，而是指向“垃圾”内存的指针。野指针是非常危险的。

* 空指针（NULL指针），是指没有存储任何内存地址的指针。野指针，是指向“垃圾内存”的指针。
* 利用野指针发消息是很危险的，会报错。也就是说，如果一个对象已经被回收了，就不要再去操作他，不要再尝试给它发消息。
* 利用空指针发消息是没有任何问题的，也就是说代码是没有错误的。


# 建议10：在64位环境下尽可能利用标记指针
* 利用标记指针，可以在指针地址中保存或附加更多的信息
* 医用标记指针处理NSNumber，直接可以把实际的值保存到指针中，而无须再去访问堆中的数据，可提高内存访问速度和整体运算速度
* 在32位和64位的环境下，isa指针会产生不同的变化。在64位环境下，标记指针会加快isa指针的处理效率


# 建议11：谨记兼容32位和64位环境下代码编写事项
* 不要将长整型数据赋予整型
* 利用NSInteger来处理32位和64位之间的转换
* 创建数据结构要注意固定大小和对齐


# 建议12：清除常量字符串和一般字符串的区别
* 由于编译器的优化，相同内容的常量字符串的地址值是完全相同的
* 如果使用常量字符串来初始化一个字符串，那么这个字符串也将是相同的常量
* 对常量字符串永远不要release


# 建议13：在访问集合时要有效考虑使用快速枚举
* 使用快速枚举，要尽可能使用枚举新的写法
* 和直接使用NSEnumerator相比，使用快速枚举可以更有效率，表达式更简洁
* 使用快速枚举，枚举更安全，因为枚举会监控枚举对象的变化，如果在枚举的过程中枚举对象发生变化会抛出一个异常
* 多个枚举可以同时进行，因为在循环中被循环对象是禁止修改的。另外，同其他的循环一样，可以适用break来停止循环或者适用continue来略过当次循环而进行到下一元素


# 建议14：有序对象适宜存于数组，而无须对象适宜存于集合
* 数组可维持持续性，故适宜存储有序的对象，但每一项必须是Objective-C对象。集合不维持秩序，故适宜存储无序对象
* 同一数组可以保存不同的对象，但不能村粗float、int、double等基本类型和nil，否则存储基本类型都会被设置为0，不能存储nil是因为数组必须用nil来结尾
* 快速枚举是访问数组中的对象的一种比较快的方法
* 使用NSArray和NSDictionary类可以直接将其内容写入磁盘进行持久化


# 建议15：存在公共键时，字典是在对象之间传递信息的绝佳方式
* 字典不仅可以作为无序对象的集合，还可以作为有序对象的集合
* 字典可作为有序对象的集合，主要依赖于键值可采用有序
* 存在公共键时，字典实在对象之间传递各种信息的绝佳方式


# 建议16：明智而审慎地使用BOOL类型
* 整型转为BOOL型，使用三元操作符，以保证返回YES或NO值
* 整型转换为BOOL型的时候要避免直接和YES做比较
* BOOL值进行逻辑原酸不但有效，而且还可以确保返回值安全地转为BOOL型，无须三元操作符


# 建议17：理解内存和Objective-C内存管理规则
* 内存可看作为内存控制器与CPU之间的桥梁，内存也就是相当于“仓库”。如何合理利用内存是写好一个高性能应用程序的关键所在。一个应用程序过量的占用内存，势必会影响到其他内存的生存
* Objective-C内存管理模式基于对象的所有权上。任何对象都会被一个或多个使用者引用，只要对象还有一个使用者，改对象就应该继续存在。如果一个对象没有使用者了，系统将自动销毁它
* 对象所有权策略是基于引用计数实现的，每一个对象有一个retaincount变量。创建对象后，它的reatiancount是1，retain之后，retainCount+1; release之后，retaincount-1; 对象的retaincount减少到0时，对象呗销毁


# 建议18：内存管理讲究好借好还，再借不难
* 在Objective-C中，释放对象应有效使用release而非autorelease，但在不适合立即回收对象的情况下，应有效使用autorelease
* 当返回一个新创建对象时，应该使用autorelease而不是release来释放所有权
* 对于拥有alloc返回的对象而言，失去释放所有权之前，应先失去对该对象的引用


# 建议19：区别开alloc、init、retain、release和dealloc之间的差异
1. alloc是创建变量，dealloc是释放变量，retain是计数加1，release是计数减1
2. 分配过程（alloc和init）不仅进行对象的内存分配，还要对它的isa实例变量和保持数初始化
3. 对象赋值时尽量采用autorelease而不是retain模式


# 建议20：优先选用存取方法来建华内存管理
* 使用存取方法管理内存，可大大降低管理方面出现的问题
* 在代码中，管理实例变量尽可能避免全部使用retain和release，降低错误的发生概率
* 在init方法和dealloc两处地方，不要使用存取方法来设置实例变量
* 实现方法的重置。有两种选择，一种是使用简便构造函数创建一个新的NSNumber对象，因此没有必要发送任何retain或release消息；另一种使用alloc创建NSNumber实例，要相应地使用release。请注意，两种方法都是用了类的set存取方法


# 建议21：对象销毁或者被移除一定考虑所有权的释放
* 从集合中移除对象，集合要释放对被移除对象的所有权
* 防止出现父对象被释放前而子对象没有被释放
* 释放对象前，要确保其他对象对该对象的所有权已经释放
* 在Objective-C中，是否负责对象的释放，需要看如何获取的对象，既要看对象的所有权策略


# 建议22：明智而审慎地使用dealloc
* 任何时候，都不要直接调用另一个对象的dealloc方法
* 不许在dealloc的最后一行调用父类的dealloc
* 不要尝试管理系统资源。应用程序终止时，对象的dealloc可能不会被调用。因为进程的内存是自动清除退出，让操作系统清理资源比调用所有的内存管理方法更有效率



# 建议23：编写代码要遵守Cocoa API约定
1. 返回对象的方法通常通过返回nil来表示创建失败或没有对象可以返回
    这种方法并不返回状态码。返回nil的约定通常用于表示运行时错误或其他非厉害的条件。Cocoa框架通过抛出例外（有顶级的例外处理代码处理），来处理诸如数组索引月结或不能识别方法选择器这样的错误。如果方法签名有要求的话，同时返回nil。
2. 某些可能返回nil的方法可以通过最后一个参数以引用的方式返回错误信息。
    对于执行失败的方法（也就是说方法返回nil），可以通过曹操返回的错误对象来确定错误的原因，或者将错误显示在对话框上。
3. 执行某些系统操作的方法通常返回一个Boolean值，以指示执行成功还是失败
4. Cocoa用空的容器对象来表示默认值或没有值---nil通常不是正当的对象参数
5. Cocoa框架要求在字典键、通知和异常名称，以及一些用字符串作为参数的方法上使用全局字符串常数，而不是一个字符串文字。
6. Cocoa框架在类型使用上是一致的，各组API之间可以进行较好的匹配

* 在API明明商，清楚是第一原则，而非简洁，切记要避免模棱两可的命名
* 在对函数或方法命名上，务必要使用动词，突显函数和方法的动性
* 在API名称上不要使用缩写，除非是众所周知的缩写
* 在对类名和类相关联的符号命名时，务必要使用前缀


# 建议24：洞悉实例变量
* 实例变量的命名规则是使用小写字符串，不包含标点符号和特殊字符。如果变量名称包含多个词，就直接把这些词连起来，且第二个及之后的词的首字母大写
* 只加入一些绝对必要的实例变量，否则容易造成大的开销。在可能的情况下，尽量从现有的实例变量中计算出一个关键值，而不是增加新的实例变量
* 永远不要将变量设置为@public，因为这违反了封装的原则
* 确保类基本属性对应的实例变量有存取方法


# 建议25：透彻了解属性的里里外外
* 属性的动态性定义，需要关键字@dynamic。属性动态性是相对于@synthesis来说的，不是由编译器自动生成setter或getter，而是在运行时动态添加的setter和getter
* 属性采用动态性，与采用静态性相比，可以简化代码的编写，便于代码的管理
* 默认情况下，可写属性使用的实例变量被称为_propertyName。如果要想使用的实例变量不同名，需要在实现中指示编译器合成的变量
* 利用类扩展可实现对属性的篡改


# 建议26：存取方法是良好的类接口必要组成部分
* 存取方法是通过对象属性的一道门槛，负责提供对象属性的访问通道，并强制对对象实例数据的封装，防止实例数据被破坏
* 方法返回的对象，需要保证对象在该作用域不被释放或修改
* 调用对象从某个方法接收到对象时，不应该对其进行释放，除非他先前进行显示的保持


# 建议27：明晓类公共领域的方法都是虚方法
* 在Objective-C中，所有的方法都是虚方法
* 实现纯虚方法依赖正式协议来实现
* 协议并不是真正的类，它只能声明方法，不能添加数据
* 非正式协议并不是真正的协议，它对代码没有约束力


# 建议28：初始化还是解码取决于是否支持归档还是解档
* 类的对象支持归档和解档，该类必须遵循NSCoding协议；必须实现对对象进行编码和解码的方法
* 类的初始化方法和initWithCoder:在角色上的并行性存在例外


# 建议29：利用键值机制访问类的私有成员变量和方法
* 在Objective-C中，类的成员变量或方法是没有绝对私有的，可以借助编译运行时机制，即瞎子摸黑机制来实现对它们的访问
* KVC和KVO在定制子类的设计时特别重要
* KVC、KVO和KVB都支持遍历
* KVC主要通过isa指针来实现其内部查找定位。KVO其设计基于设计模式中的观察者模式。KVB和KVO最明显的使用场景就是在一些界面实时显示很强的地方


# 建议30：浅复制适宜指针而深复制适宜数据
* 浅复制，是将原始对象的指针值复制到副本中，从而达到原始对象和副本共享引用数据的目的；深复制，是复制指针所引用的数据，并将其赋给副本的实例变量
* 一般情况下，可以被视为数据容器的指针型实例变量往往被深复制，而更复杂的实例变量则被浅复制
* 实例变量的set方法的实现要能够反映出需要使用的复制类型。如果相应的set方法复制了新的值，那么就应该深复制这个实例变量
* 如果实例变量的set方法只是简单地将新的值赋给实例变量，而没有复制或保留它，那么就应该浅复制这个实例变量


# 建议31：明智而审慎地使用NSCopying
* 基类没有实现NSCopying，那么子类的实现必须复制它所继承的实例变量，以及那些在类中声明的实例变量，最安全的方式是使用alloc、init和set方法
* 类继承了NSCopying的行为，并声明了额外的实例变量，那么也需要实现copyWithZone：
* 如果基类使用了或者有可能使用过NSCopyObject，那么必须使用有别于alloc和init函数的情况，用不用的方式处理实例变量


# 建议32：使用协议来实现匿名对象的提供
* 采用协议，可灵活实现。实现抽象不应该依赖于细节，而细节应该依赖于抽象，降低声明和实现的耦合度
* 设计程序采用协议，可减少继承类的复杂性


# 建议33：使用分类把类的实现拆分成不同的文件
* 利用类别机制，可将同一个类的实现，由一个常规的实现文件拆分成多个实现文件
* 把同一个类的实现文件拆分成多个实现文件，适合类的实现文件大多比较庞大
* 把同一个类的实现文件拆分成多个实现文件，拆分的标准多是以同类型或同业务类型等来作为参考


# 建议34：明智地使用内省可使程序更加高效和健壮
1. 评估继承关系
2. 方法实现和协议遵循
3. 对象的比较

* 内省是对象揭示自己作为一个运行时对象的详细信息的一种能力。这些详细信息包括对象在继承树上的位置，对象是否遵循特定的协议，以及是否可以响应特定的消息
* 内省有助于避免错误地进行消息派发、错误地假设对象相等，以及类似的问题
* NSObject协议和类定义了很多内省方法，用于查询运行时信息，以便根据对象的特征进行识别
* 在Cocoa框架的所有isEqualToType:方法中，nil都不是正当的参数，这些方法的实现在接收到nil参数时会抛出异常。然后为了向后兼容，Cocoa框架中的isEqual:方法可以接受nil值，在这种情况下返回NO


# 建议35：尽量使用不可变性对象而非可变性对象
* 尽量不要把可变对象存储到集合对象中，否则容易导致存储的可变对象呗破坏或变成无效
* 在开销上，可变对象比不可变对象要大，因为可变对象必须动态管理一个可变的辅助存储————在必要时分配或解除分配内存块，所以比相应的不可变版本效率低
* 不能确定对象是否可变，则将她当成不可变处理


# 建议36：利用复合能巧妙地把两个类或两个对象融合
* 在OOP编程中有两个技术用于描述类与类对象或对象与对象之间的关系：一个是继承，另一个是复合
* 复合是通过类中声明一个指向另一个类对象的指针作为实例变量，从而将这个两个类进行复合
* 使用new创建对象的时候，实际发生了两个步骤：第一个步骤，为对象分配内存，也就是说对象获得存储其实例变量的内存块；第二步，就是自动调用init方法，初始化对象使其处于可用状态。没有被初始化的指针都是nil
* 在Objective-C中所有对象之间的交互都是通过指针实现的


# 建议37：使用类扩展来隐藏实现的细节
* 类扩展，从一定程度而言，可称为匿名类别
* 利用类扩展隐藏私用信息
* 如果打算将私有的方法或属性用来选择相关的类，可以在单独的头文件中声明类扩展， 并把其导入到需要它的源文件中


# 建议38：使用内联块应注意避免循环引用
* 在内联块中能直接引用self,但是注意避免导致循环引用
* 避免由于在内联块中直接引用self导致的循环引用，较好的方式，引进弱引用来预防
* 在非内联块不能直接访问self，只能通过将self当作参数传递到块中才能使用，并且此时的self只能通过setter或getter方法访问其属性，不能使用句点式方法



# 建议39：利用类别把方法添加到现有的类


# 建议40：通过强弱引用来管理对象的所有权
* `__weak`对面是`__strong`。不必明确指定`__strong`的
* 父对象应该`__strong`引用子对象，子变量应该`__weak`引用父对象
* 只要该变量实在范围内，变量就会保持对对象的`__strong`引用，或直至它被重新分配给另一个对象或nil
* 对一些不支持`__weak`引用的类，可通过Unsafe Unretained引用来暗度陈仓
* 使用`__weak`引用来避免循环retain


# 建议41：明确isa在继承上的作用
* 在OC中，每个对象都隐藏着一个数据结构isa指针
* isa指针指向的是对象的类，这个类也是一个对象，有自己的权
* 在OC中，每个对象还都保留一个超类的指针，通过指针可以调度自己已有的方法和调度基类



# 建议42：利用类别和协议实现类似多重继承的机制
* 类别，实现了类的相关方法的模块化，把不同的类方法分配到不同的分类文件中
* 类别可以重载原始类的方法，但不推荐这么做，这么做的后果是再也不能访问原来的方法。如果确实要重载，正确的选择是创建子类
* 和普通接口有所区别的是，类别的实现文件中可以不必实现所有声明的方法，只要不去调用它
* 协议就是一系列不属于任何类的方法列表，其中声明的方法可以被任何类实现。协议并不是真正的类，他只能声明方法，不能添加数据



# 建议43：类别和类扩展是类继承的延续性扩展
> 类扩展就是匿名分类
* 子类体现了类的上下级关系，而类别是类间的平级关系
* 类别具有替换特性，也就是说，如果类别方法与类内某个方法具有同样的方法签名，那么类别里的方法就会替换类的原有方法
* 类别是为类增加外部方法的话，类扩展就是用做类的内部扩展
* 类别关注的中心是代码设计，把不同功能的方法分开



# 建议44：继承基类的实现行为勿忘调用super
* 调用基类方法，以使用该类提供的服务
* 覆盖基类的方法，以便将自己的代码引入到定义的程序模型中
* 如果打算补充基类实现的行为，请调用super
* 如果打算替换基类实现的行为，就不要调用super




# 建议45：设计模式是特定环境下的特定问题的解决方案
* 设计模式是特定环境下的特定问题的解决方案
* 设计模式是某种特定设计的模板或指导原则
* 在某种意义上，具体设计师设计模式的一个实例化



# 建议46：MVC模式是一种复合或聚合模式
MVC模式是一个相当老的设计模式，它是一种高级别的模式，关注的是应用程序的全局架构，并根据各种对象在程序中发挥的作用对其进行分类。他也是个复合的模式，因为它是由几个更加基本的模式组成的。

面向对象的程序在设计上采用MVC模式会带来几个方面的好处。
1. MVC对象的作用和关系
MVC设计模式考虑三种对象：模型对象、视图对象、和控制器对象。模式定义了这三中队形在应用程序中充当的角色，以及他们的通讯路径。三种对象中的每一种都和其他两种按抽象的边界区分，并和其他对象进行跨边界的通讯。

2. Cocoa控制器对象的类型
3. MVC是一个复合的设计模式
4. MVC应用程序的设计原则
5. Cocoa中的模型-视图-控制器

* MVC是一种高级别的模式，关注的是应用程序的全局架构，斌根据各种对象在程序中发挥的作用对其进行分类
* MVC是一个复合的设计模式，是由合成、策略和观察者模式组成的



# 建议47：对象建模在数据库中也广泛使用
* 实体-关系建模是一种边线对象的方式，这里的对象通常用于介绍数据源的数据结构，是那些数据结构可以被映射为面向对象系统中的对象
* 实体-关系建模并不仅仅在Cocoa中使用，它和数据库技术中使用的术语和规则一起，是广泛使用的模式。这种对象表示有助于数据源中对象的存储和获取



# 建议48：类族可简化框架的公开架构而又不减少功能的丰富性
* 类族基于抽象工厂设计模式
* 类族，可以用于隐藏实现的详细细节，为调用者提供一个简单的接口
* 类族也可以有多个基类，后者就是继承的前者。对一些大同小异的问题，往往会有不错的效果



# 建议49：委托用于界面控制，而数据源用于数据控制
* 委托是一种对象，当向外委托任务的对象遇到程序中的事件时，它的委托可以代表它对事件进行处理，或者和它进行协调
* 委托是一个对象有可能在没有进行继承的情况下改变另一个对象的行为
* 数据源很想委托，区别在于委托处理的是用户界面的控制，而数据源处理的是数据的控制



# 建议50：了解对象的alloc和init...
* alloc方法使用应用程序默认的是虚存区。区是一个按页对齐的内存区域，用于存放应用程序分配的对象和数据
* alloc分配过程不仅进行对象的内存分配，还初始化对象的两个小而非常重要的属性，即它的isa实例变量和保持数
* 子类可以不采用带参数的初始化方法，而是实现一个简单的init方法，并在初始化后马上使用set存取方法，将对象设置为有用的初始状态
* 工厂方法则可以避免为可能没有用的对象盲目分配内存



# 建议51：直接访问实例变量的init...方法
* 应始终从内初始化方法来直接访问实例变量，因为在设置属性时，改对象的其余部分可能尚未完全初始化
* 父类可能无法正确初始化的对象，并返回nil，故要经常检查，确保self不为零，然后在执行自己的初始化
* 继承一个类要使用多个初始化方法时，写初始化方法，要考虑到重写父类指定的初始值设定项来执行自己的初始化，或添加自己的附加初始值设置项


# 建议52：初始化方法必须以init字母开头
* 如果一个对象没有实现自己的初始化方法，Cocoa就会调用其最近的祖先对象的方法
* 对于不需要初始化其数据的子类，重载init方法就可以了，但是常见的情况是初始化阶段需要根据外部的数据来设置对象的初始状态



# 建议53：从init...方法得到的对象可能是不想要的
* init...方法的到的对象可能不是读者认为的、正在被初始化的对象
* init...方法并不是一定能执行其他对象请求的初始化
* 在创建对象是，通常应该在处理之前检查返回值是否为nil
* 一旦对象被初始化了，就不应该在进行初始化，否则，容易产出抛出



# 建议54：实现init...方法的唯一性或者指定性并非不可能
* 实现init... 方法的唯一性或者指定性并为不可能
* 调用super的初始化方法可以确保继承链上方的类定义的实例变量都率先得到初始化
* 在创建子类时需要关注通过继承得到的初始化方法。因为，有些时候，基类的init...方法已经为类做好足够的初始化，但是更多的可能是没有做好的，因此应该对其进行重载



# 建议55：init...方法有轻重级别之分
* 进行对象的初始化，要注意轻重之分
* 指定初始化方法是通过发向super的消息彼此链接在一起的，而其他的初始化方法则通过发向self的消息和其所属类的指定初始化方法链接在一起




# 建议56：Objective-C和Swift的互用性基于映射机制
* 互用性是让Swift和Objective-C相结合的一种特性，即在一种语言编写的文件中访问和使用另一种语言编写的代码
* 可以在初始化时显式地声明对象的类型，也可以忽略它，Swift的类型接口能够正确判断对象的类型
* Swift中的AnyObject的协议类型与Objective-C中的id一样



# 建议57：利用Swfit的特性可增强已有的Objective-C代码
* 在Swift中，利用Objective-C中已有的熟悉的可靠的类、方法和框架创建新类，并结合Swift提供的现代化和更有效的语言特性增强性新创建的类
* Swift的类，可继承Objective-C中的类：适配的Objective-C中的协议



# 建议58：洞悉Objective-C和Swift类型装换的处理机制
* Swift会自动将一些Objective-C类型转换为Swift类型，并将Swift类型转换为Objective-C类型



# 建议59：C语言的数据类型在Swift中有所变有所不变


# 建议60：Swift和Objective-C兼容性是基于混搭机制


# 建议61：利用迁移机制实现Objective-C代码的重生



