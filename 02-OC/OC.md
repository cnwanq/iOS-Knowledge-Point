> Objective-C是C语言的超类，在C语言的基础上增加了面向对象功能。是开发Mac OS X、iPhone、iPad应用的主要语言

# 面向对象的编程
万事万物皆对象。
对象有属性，并且能够接受消息来进行相应的处理。
消息是对象之间通信的唯一手段。请求、查询、应答和一次通知等，所有的通信和控制都是通过手法消息完成的。
独享收到消息后，会对消息进行解析，完成相应的处理并返回结构。具体的处理方法和这个对象的内部实现相关，这叫作方法。
方法中写明了程序的各种操作的实现和规则。

* 消息传递
消息传递的时候可以适用对象或者基本数值作为参数。另外，消息处理的结果也可以返回一个对象或基本数值。
送信的对象称为发送者，收信的对象称为接受者。

* 模块的抽象化
    对象具体如下特征：
    * 可认为分辨出这是一个对象
    * 拥有属性
    * 能够想起他对象发送消息
    * 能够接收消息，并作为相应的处理
    * 消息的处理是通过对象的方法完成的
使用对象的概念对问题进行抽象化的方法叫作面向对象。
使用对象的概念来分析如何做一个软件叫作面向对象分析 OOA。
已对象为基础来设计软件叫作面向对象的设计 OOD。
编程过程中使用面向对象的概念叫作面向对象的程序设计 OOP。

面向对象四要素：抽象，封装，继承，多态


# OC程序设计

## 对象和消息

* 消息表达式
在OC中，id类型是一个独特的数据类型，id类型的变量可以存放热河数据类型的对象。
```Objective-C
id obj;
```
向obj发送msg消息的语法如下：
```Objective-C
[obj msg];
```
消息的关键字的末尾有`:`时，表示这个消息带有参数。

* 消息选择器
函数式通过函数名来区分的，消息则是通过消息名来区分的。消息名又称为消息选择器、选择器或方法。

* 实例变量的生成和初始化
生成一个类的对象只需要给类名发送一个alloc消息就可以了
```Objecive-C
[ClassName alloc];
```
alloc执行后即可完成对象所需要的存储空间的分配，但还没有对对象进行初始化。
不同类会提供不同的初始化方法，同一个类也可能提供多个初始化方法。
```Objective-C
[[ClassName alloc] init];
```
通常嵌套调用alloc和init来生成一个对象。
另外，对象生成后只调用一次初始化方法，来为对象的各个变量设置初值。初始化方法并不具备将对象中的信息重置的功能。如果需要将对象中的属性重置，则需要额外实现一个重试专用的函数。

另外，有的类也可以不通过alloc而是用别的方法来生成对象，有的类也有可能会返回一个初始化好的对象。

## 类的定义

OC中的类是如何定义的。
OC中接口 interface 和实现 implementation 是分离开的。

* 类的接口声明
类的接口部分定义了类的实例变量和方法。类的接口声明通常声明为头文件，提供给要调用这个类的模块引用。
```Objective-C
@interface ClassName: SuperClassName
{
    // 实例变量的定义；

}
// 方法声明；

@end
```
在OC里面，类接口的声明一编译指令@interface开头并以@end结束，所有OC编译指令都以@字符开头，以便和C语言的字符串区分。

## 类的实现

类的实现部分已编译指令@implementation开始，以@end结束。
```Objective-C
@implemmentation 类名
// 方法的定义
@end
```

## 程序的书写风格

* 头文件的引入
OC使用 #import 来引入头文件，#import和#include的基本功能一样，稍有不用的是#import不存在嵌套引用的问题。
不仅仅在OC，在C语言中，当软件的规模变大而需要多个头文件时，很有可能会出现头文件被重复引入的问题。同一个头文件被重复引入后，就会出现二重定义的错误。C语言中一般通过在头文件的最开始加上宏定义的方法来避免这个问题。
```C
#ifndef __MYLIB_H__
#define __MYLIB_H__
#endif /* __MYLIB_H__ */
```

__MYLIB_H__ 是这个头文件专用的宏定义。当头文件第一次被引入的时候，因为这个宏名还没有定义，所以 #ifndef和#endif之间的内容会被读入，同时 __MYLIB_H__也会被定义。在这之后，当头文件再次被引入的时候，因为__MYLIB_H__已被定义，所以#ifndef和#endif之间的内容也就不会被再次加载了。

不过这种方法比较麻烦，而且容易出错。OC中的#import内置了判断同一个文件是否已经被引入的功能。所以，不使用宏定义的方法也能够防止同一个文件被重复引用。

# 类和继承

## 继承的概念

* 父类和子类
我们在定义一个新类的时候，经常会遇到要定义的新类是某个类的扩展或者是对某个类的修正这种情。如果可以在已有类的基础上追加内容来定义新类，那么新类的定义就会变得简答。
通过扩展或者修改既有类来定义新类的方法叫作继承。在继承关系中，被继承的类称为父类，通过继承关系新建的类称为子类。
继承以为这子类继承了父类的所有特性、父类的数据成员和成员函数自动称为子类的数据成员和成员函数。
除此职位，子类还可以
    * 追加新的方法
    * 追加新的实例变量
    * 重新定义父类中的方法

如果子类中追加新的实例变量二不变更方法则没有任何意义。子类中重新定义父类的方法叫作重写。

## 利用继承定义新类

* 继承的定义
```Objective-C
@interface ClassName : SuperClassName
{
    // 实例变量的声明

}
// 方法的声明

```

* 调用父类的方法
可以在子类的方法中通过 super 调用父类的方法。

## 方法定义时的注意事项
* 局部方法
实现接口声明中的方法时，可把具备独立功能的部分独立出来定义成子方法。一般，这些字方法都只供内部调用，不需要包含在类的接口中对外公开。


# 对象的类型和动态绑定

## 动态绑定
* 什么是动态绑定
OC中的消息是在运行时才去绑定的。运行时系统首先会确定接收者的类型（动态类型识别），然后根据消息名在类的方法列表里选择相应的方法执行，如果没有找到就到父类中继续寻找，假如一直没找到NSObject也没有找到要调用的方法，就会报告上述不能识别的错误。
**动态绑定**指的就是程序执行时才确定对象的属性和需要响应的消息
C语言支持动态绑定，在程序执行前基本上都已经绑定好了各种方法。但是通过C语言中的函数指针也能模拟动态绑定的实现。

* 多态
多态是指，统一操作作用于不同的类的实例时，将产生不同的执行结果。


## 作为类型的类

* 把类作为一种类型
至今为止我们声明过的对象都是id类型，除了使用id类除外，我们还可以吧定义好的类作为对象的类型。

* 空指针nil
OC中，nil表示一个空的对象，这个对象的指针指向空。nil是指向id类型的指针，值为0。初始化方法失败的时候通常会返回nil。
新生成一个实例变量的时候，alloc方法会把数值类型的实例变量初始化为0，id和其他类型的指针变量也会被初始化为nil。
返回值为id类型的方法中，如果处理出错的话一般也会返回nil。

给nil变量发送消息，消息也不会被发送


* 静态类型检查
在OC中id数据类型可以用来存储任何类型的对象，单绝大多数情况下我们还是讲一个变量声明为特定类的对象，这种情况成为静态类型。使用静态类型时，编译器在编译时可以进行类型检查，如果类型不符会提示警告。

* 静态类型检查的总结
1. 对于id类型的变量，调用任何方法都能够通过编译（当然调用不恰当的方法会出现运行时错误）
    id 数据类型可以系统来存储任何类型的对象。这是由于这个原因，编译器并不知道id中存储的是哪个类的变量，所以无法通过->来获取类的实例变量或方法，也就没法完成类型检查。
2. id类型的变量和被定义为特定类的变量之间是可以互相赋值的。
    这里的赋值是一个广义的含义，包括方法或函数的参数的传递、返回值的接收等。
3. 被定义为特定类对象的变量（静态类型），如果调用了类或父类中未定义的方法，编译器就会提示警告
4. 若是静态类型的变量，子类类型的实例变量可以赋值给父类类型的实例变量
    需要注意的是，如果这个变量中调用了子类特有的方法，会提示警告信息
5. 若是静态类型的变量，父类类型的实例变量不可以赋值给子类类型的实例变量
    因为父类类型的变量无法对应子类中特有的方法，所以这种赋值会提示警告
6. 若要判断到底是哪个类的方法被执行了，不要看变量所声明的类型，而要看实际执行时这个变量的类型
7. id类型并不是NSObject *类型

## 编程中的类型定义

* 签名不一致时的情况
消息选择器中并不包含参数和返回值的类型信息，消息选择器和这些类型嘻嘻结合起来构成签名，签名被用于在运行时标记一个方法。接口文件中方法的定义也叫做签名。

Cocoa 提供了类 NSMethodSignature，以面向对象的方式类记录方法的参数个数、参数类型和返回值类型等信息。这个类的实例也叫做方法签名。
方法通过消息选择器被调用，选择器并不包含参数和返回值的信息。那么如果选择器相同二参数和返回值不一样的话，会怎么样？
如果消息接收者和参数的类型是运行时确定的，那么消息签名不唯一的话编译就会出错。
也就是说，OC中选择器相同的消息，参数和返回值的类型也应该是相同的。
编译的时候，如果编译器发现了签名不一致的情况，就会提示警告，并显示出问题的地方。

* 类的前置声明
当我们定义一个类的时候，有时会将类实例变量、类方法的参数和返回值的类型指定为另外一个类。

一种方法是，在新定义的类的接口文件中引入原有类的头文件。

另外一种方法是，在类型定义的时候使用一个类名，如：
```Objective-C
@class ClassName;
```
通过编译指令@class告知编译器，这是一个类名，这种写法被叫作前置声明。
class指令的后面可以一次接多个类，不同的类之间用","来分割，最后用";"来标识前置声明的结束。

通过使用@class可以提升程序整体的编译速度。但要注意的是，如果新定义的类中药使用原有类的具体成员或方法，就一定要引入原有类的头文件。
@class的另外一个好处是，当多个接口出现类的嵌套定义时，如果只是互相包含对方的头文件无法解决，只能通过类的前置声明来解决。


* 强制类型转换
有些情况下必须使用前置类型转换。

## 实例变量的数据封装

* 实例变量的访问权限
OC原则上不允许对象外直接访问对象的实例变量。

* 访问器
OC不允许从外部直接访问和修改实例对象的属性。而仅仅可以访问同一个类的其他实例对象的变量。我们通常会定义专门的方法来访问或修改实例变量。
定义修改属性的方法时，可以用set作为前缀，之后接要更改的属性的名称，属性名的第一个字母要求大写。
Cocoa的OC直接使用属性名作为方法名，作为getter方法。

为什么不允许直接方位成员属性，而要通过 getter和setter方法来完成操作呢？
一切都是为了封装。类中包含哪些实例变量以及怎么使用这些实例变量都和类的实现紧密相关。而如果运行直接访问了类的实例变量，那么当类的实现发生了变化，实例变量被删除或者作用发生了变化时，所有调用这个类的外部模块都需要更改。
而如果使用了getter/setter的形式，那么当类的实现发生了变化时，则只需要更改getter/setter接口

同样的道理，父类和子类之间也要尽可能地多利用getter/setter方法。

* 实例变量的可变性
虽然一般情况下不允许从国外部直接访问对象的实例变量，但如果一定要访问的话，也可以通过其他办法来访问。
能否从外部访问实例变量决定了访问的可见性。OC中有四种可见性修饰符。
    * @private
    * @protected
    * @public
    * @package

* 在实现部分中定义实例变量
允许在实现部分中定义类的实例变量。
让一个变量对外不可见有两种方法，一种是吧变量的可见性属性设为@private,另一种就是把变量的定义在实行文件中。相比之下第二种方法封装性更好一点，同事你也可以清楚地表明这些变量对外是不可见的。

## 类对象

* 什么是类对象
面向对象的语言中对类有两种认识，一种是认为类只作为类型的定义，程序运行时不作为实体存在；另外一种是认为类本身也作为一个对象存在。后面一种对象叫作类对象。

类对象有自己的方法和变量，分别被称为类方法和类变量。

OC中只有类方法的概念，没有类变量的概念。

通过向类发送消息可以生产实例对象，那么类对象自身是什么时候生产的呢？类对象是程序执行时自动生成的，每个类只有一个类对象，不需要手动生成。

* 类对象的类型
id类型可以表示任何对象，类对象也可以用于id类型来表示。OC中还专门定义了一个Class类型用来表示类对象，所有类对象都是Class类型。Class和id一样都是指针类型，只是一个地址，并不需要了解实际指向的内容。Nil被用来表示空指针。

将类名定义为消息接收者是类对象特有的功能，除此之外类名只能在类型定义时使用。

* 类方法的定义
实例方法在接口声明和实现文件中都以 - 开头，类方法则与此相反，以 + 开头。

* 类变量
OC不支持类变量。
OC通过实现文件中定义静态变量的方法来代替类变量。
OC在现实文件中定义了静态变量后，该变量的作用域就变为只在该文件内有效。只有在类的类方法和实例方法可以访问这个变量。
static 变量的作用域仅限于定义它的文件内，所以子类无法访问父类中定义的static变量。
可以通过定义类方法来解决这个问题。

* 类对象的初始化

OC中实例对象的生成一般分为两步，第一步是通过alloc为对象分配内存，第二步是对内存进行初始化，也就是对对象的各个成员赋予初值。

* 初始化方法的返回值
初始化的方法返回值都应该设为id类型。
在继承存在的情况下，尽可能地避免使用静态类型吧代码写死。


# 基于引用计数的内存管理

## 动态内存管理
* 内存管理的必要性
如果程序没能妥善管理内存，运行过程中就不能但不能释放不再使用的内存，而且还会不停地分配内存， 这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会因为内存耗尽而奔溃。

就好像漏水一样，程序未能释放的内存已经不再使用的内存叫作内存泄漏。
如果访问了已经被释放的内存，则会造成数据错误，严重时甚至会导出程序异常中止。在指针所指向的对象已经被释放或收回的情况下，该指针就称为悬垂指针或野指针。继续使用这种指针会造成程序崩溃。

OC会通过向类对象发送alloc消息生成实例对象，alloc的作用就是分配内存。alloc方法返回的值是id类型，id是指针类型，指向的是为实例对象分配的内存。生成的实例对象用完之后不被释放的话，就会发生内存泄漏。如果给已经释放了的实例对象发送信息，可能会造成程序错误甚至异常终止。OC的程序中一定要注意内存管理。

在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有生命短暂的临时对象。对象之间也有可能互相引用，构成结构复杂的数据结构。

* 引用计数、自动引用计数和自动垃圾回收
Cocoa的OC提供了一种动态的内存管理方式，称为引用计数。这种方式会跟踪每个对象引用的次数，当对象的引用次数为0时，系统就会释放这个对象所占用的内存。  -- 基于引用计数的内存管理

比引用计数内存管理更高级一点的就是自动引用计数 ARC，自动引用计数使开发者不需要考虑何时该使用 retain、release、autorelease 来管理内存，他提供了自动评估对象生存期的功能，在编译期间会自动加入合适的管理内存的方法。

除了ARC外，OC还提供自动内存管理机制--垃圾回收。使用垃圾回收时，就不在需要通过引用计数来管理创建的对象，系统会自动识别哪些对象仍然使用、哪些对象可以回收。

ARC 自动引用计数使一个编译技术，利用此计数可以简化OC在内存管理方面的工作量。


* ARC 的基本注意事项
    * 不能在程序中定义和使用下面这些函数：retain、release、autorelease和retainCount
    * 使用 @autoreleasepool 代替 NSAutoreleasePool
    * 方法命名必须遵循命名规则，不能随意定义以alloc/ini/new/copy/mutableCopy开头且和所有权操作无关的方法
    * 不用 dealloc 中释放实例变量，也不需要调用 [super dealoc]
    * 编译代码时使用编译器 clang，并加上编译选项 -fobjc-arc

## 循环引用和弱引用
* 循环引用




# 垃圾回收



# 属性声明



# 基类NSObject和运行时系统




# Foundation



# 范畴




# 抽象类和类簇



# 协议 



# 对象的复制及存储




# 块对象




# 消息发送模式


# 应用的构造



# 异常和错误


# 并行编程



# 键值编码



