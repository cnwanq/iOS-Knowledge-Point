> Objective-C是C语言的超类，在C语言的基础上增加了面向对象功能。是开发Mac OS X、iPhone、iPad应用的主要语言

# 面向对象的编程
万事万物皆对象。
对象有属性，并且能够接受消息来进行相应的处理。
消息是对象之间通信的唯一手段。请求、查询、应答和一次通知等，所有的通信和控制都是通过手法消息完成的。
独享收到消息后，会对消息进行解析，完成相应的处理并返回结构。具体的处理方法和这个对象的内部实现相关，这叫作方法。
方法中写明了程序的各种操作的实现和规则。

* 消息传递
消息传递的时候可以适用对象或者基本数值作为参数。另外，消息处理的结果也可以返回一个对象或基本数值。
送信的对象称为发送者，收信的对象称为接受者。

* 模块的抽象化
    对象具体如下特征：
    * 可认为分辨出这是一个对象
    * 拥有属性
    * 能够想起他对象发送消息
    * 能够接收消息，并作为相应的处理
    * 消息的处理是通过对象的方法完成的
使用对象的概念对问题进行抽象化的方法叫作面向对象。
使用对象的概念来分析如何做一个软件叫作面向对象分析 OOA。
已对象为基础来设计软件叫作面向对象的设计 OOD。
编程过程中使用面向对象的概念叫作面向对象的程序设计 OOP。

面向对象四要素：抽象，封装，继承，多态


# OC程序设计

## 对象和消息

* 消息表达式
在OC中，id类型是一个独特的数据类型，id类型的变量可以存放热河数据类型的对象。
```Objective-C
id obj;
```
向obj发送msg消息的语法如下：
```Objective-C
[obj msg];
```
消息的关键字的末尾有`:`时，表示这个消息带有参数。

* 消息选择器
函数式通过函数名来区分的，消息则是通过消息名来区分的。消息名又称为消息选择器、选择器或方法。

* 实例变量的生成和初始化
生成一个类的对象只需要给类名发送一个alloc消息就可以了
```Objecive-C
[ClassName alloc];
```
alloc执行后即可完成对象所需要的存储空间的分配，但还没有对对象进行初始化。
不同类会提供不同的初始化方法，同一个类也可能提供多个初始化方法。
```Objective-C
[[ClassName alloc] init];
```
通常嵌套调用alloc和init来生成一个对象。
另外，对象生成后只调用一次初始化方法，来为对象的各个变量设置初值。初始化方法并不具备将对象中的信息重置的功能。如果需要将对象中的属性重置，则需要额外实现一个重试专用的函数。

另外，有的类也可以不通过alloc而是用别的方法来生成对象，有的类也有可能会返回一个初始化好的对象。

## 类的定义

OC中的类是如何定义的。
OC中接口 interface 和实现 implementation 是分离开的。

* 类的接口声明
类的接口部分定义了类的实例变量和方法。类的接口声明通常声明为头文件，提供给要调用这个类的模块引用。
```Objective-C
@interface ClassName: SuperClassName
{
    // 实例变量的定义；

}
// 方法声明；

@end
```
在OC里面，类接口的声明一编译指令@interface开头并以@end结束，所有OC编译指令都以@字符开头，以便和C语言的字符串区分。

## 类的实现

类的实现部分已编译指令@implementation开始，以@end结束。
```Objective-C
@implemmentation 类名
// 方法的定义
@end
```

## 程序的书写风格

* 头文件的引入
OC使用 #import 来引入头文件，#import和#include的基本功能一样，稍有不用的是#import不存在嵌套引用的问题。
不仅仅在OC，在C语言中，当软件的规模变大而需要多个头文件时，很有可能会出现头文件被重复引入的问题。同一个头文件被重复引入后，就会出现二重定义的错误。C语言中一般通过在头文件的最开始加上宏定义的方法来避免这个问题。
```C
#ifndef __MYLIB_H__
#define __MYLIB_H__
#endif /* __MYLIB_H__ */
```

__MYLIB_H__ 是这个头文件专用的宏定义。当头文件第一次被引入的时候，因为这个宏名还没有定义，所以 #ifndef和#endif之间的内容会被读入，同时 __MYLIB_H__也会被定义。在这之后，当头文件再次被引入的时候，因为__MYLIB_H__已被定义，所以#ifndef和#endif之间的内容也就不会被再次加载了。

不过这种方法比较麻烦，而且容易出错。OC中的#import内置了判断同一个文件是否已经被引入的功能。所以，不使用宏定义的方法也能够防止同一个文件被重复引用。

# 类和继承

## 继承的概念

* 父类和子类
我们在定义一个新类的时候，经常会遇到要定义的新类是某个类的扩展或者是对某个类的修正这种情。如果可以在已有类的基础上追加内容来定义新类，那么新类的定义就会变得简答。
通过扩展或者修改既有类来定义新类的方法叫作继承。在继承关系中，被继承的类称为父类，通过继承关系新建的类称为子类。
继承以为这子类继承了父类的所有特性、父类的数据成员和成员函数自动称为子类的数据成员和成员函数。
除此职位，子类还可以
    * 追加新的方法
    * 追加新的实例变量
    * 重新定义父类中的方法

如果子类中追加新的实例变量二不变更方法则没有任何意义。子类中重新定义父类的方法叫作重写。

## 利用继承定义新类

* 继承的定义
```Objective-C
@interface ClassName : SuperClassName
{
    // 实例变量的声明

}
// 方法的声明

```

* 调用父类的方法
可以在子类的方法中通过 super 调用父类的方法。

## 方法定义时的注意事项
* 局部方法
实现接口声明中的方法时，可把具备独立功能的部分独立出来定义成子方法。一般，这些字方法都只供内部调用，不需要包含在类的接口中对外公开。


# 对象的类型和动态绑定

## 动态绑定
* 什么是动态绑定
OC中的消息是在运行时才去绑定的。运行时系统首先会确定接收者的类型（动态类型识别），然后根据消息名在类的方法列表里选择相应的方法执行，如果没有找到就到父类中继续寻找，假如一直没找到NSObject也没有找到要调用的方法，就会报告上述不能识别的错误。
**动态绑定**指的就是程序执行时才确定对象的属性和需要响应的消息
C语言支持动态绑定，在程序执行前基本上都已经绑定好了各种方法。但是通过C语言中的函数指针也能模拟动态绑定的实现。

* 多态
多态是指，统一操作作用于不同的类的实例时，将产生不同的执行结果。


## 作为类型的类

* 把类作为一种类型
至今为止我们声明过的对象都是id类型，除了使用id类除外，我们还可以吧定义好的类作为对象的类型。

* 空指针nil
OC中，nil表示一个空的对象，这个对象的指针指向空。nil是指向id类型的指针，值为0。初始化方法失败的时候通常会返回nil。
新生成一个实例变量的时候，alloc方法会把数值类型的实例变量初始化为0，id和其他类型的指针变量也会被初始化为nil。
返回值为id类型的方法中，如果处理出错的话一般也会返回nil。

给nil变量发送消息，消息也不会被发送


* 静态类型检查
在OC中id数据类型可以用来存储任何类型的对象，单绝大多数情况下我们还是讲一个变量声明为特定类的对象，这种情况成为静态类型。使用静态类型时，编译器在编译时可以进行类型检查，如果类型不符会提示警告。

* 静态类型检查的总结
1. 对于id类型的变量，调用任何方法都能够通过编译（当然调用不恰当的方法会出现运行时错误）
    id 数据类型可以系统来存储任何类型的对象。这是由于这个原因，编译器并不知道id中存储的是哪个类的变量，所以无法通过->来获取类的实例变量或方法，也就没法完成类型检查。
2. id类型的变量和被定义为特定类的变量之间是可以互相赋值的。
    这里的赋值是一个广义的含义，包括方法或函数的参数的传递、返回值的接收等。
3. 被定义为特定类对象的变量（静态类型），如果调用了类或父类中未定义的方法，编译器就会提示警告
4. 若是静态类型的变量，子类类型的实例变量可以赋值给父类类型的实例变量
    需要注意的是，如果这个变量中调用了子类特有的方法，会提示警告信息
5. 若是静态类型的变量，父类类型的实例变量不可以赋值给子类类型的实例变量
    因为父类类型的变量无法对应子类中特有的方法，所以这种赋值会提示警告
6. 若要判断到底是哪个类的方法被执行了，不要看变量所声明的类型，而要看实际执行时这个变量的类型
7. id类型并不是NSObject *类型

## 编程中的类型定义

* 签名不一致时的情况
消息选择器中并不包含参数和返回值的类型信息，消息选择器和这些类型嘻嘻结合起来构成签名，签名被用于在运行时标记一个方法。接口文件中方法的定义也叫做签名。

Cocoa 提供了类 NSMethodSignature，以面向对象的方式类记录方法的参数个数、参数类型和返回值类型等信息。这个类的实例也叫做方法签名。
方法通过消息选择器被调用，选择器并不包含参数和返回值的信息。那么如果选择器相同二参数和返回值不一样的话，会怎么样？
如果消息接收者和参数的类型是运行时确定的，那么消息签名不唯一的话编译就会出错。
也就是说，OC中选择器相同的消息，参数和返回值的类型也应该是相同的。
编译的时候，如果编译器发现了签名不一致的情况，就会提示警告，并显示出问题的地方。

* 类的前置声明
当我们定义一个类的时候，有时会将类实例变量、类方法的参数和返回值的类型指定为另外一个类。

一种方法是，在新定义的类的接口文件中引入原有类的头文件。

另外一种方法是，在类型定义的时候使用一个类名，如：
```Objective-C
@class ClassName;
```
通过编译指令@class告知编译器，这是一个类名，这种写法被叫作前置声明。
class指令的后面可以一次接多个类，不同的类之间用","来分割，最后用";"来标识前置声明的结束。

通过使用@class可以提升程序整体的编译速度。但要注意的是，如果新定义的类中药使用原有类的具体成员或方法，就一定要引入原有类的头文件。
@class的另外一个好处是，当多个接口出现类的嵌套定义时，如果只是互相包含对方的头文件无法解决，只能通过类的前置声明来解决。


* 强制类型转换
有些情况下必须使用前置类型转换。

## 实例变量的数据封装

* 实例变量的访问权限
OC原则上不允许对象外直接访问对象的实例变量。

* 访问器
OC不允许从外部直接访问和修改实例对象的属性。而仅仅可以访问同一个类的其他实例对象的变量。我们通常会定义专门的方法来访问或修改实例变量。
定义修改属性的方法时，可以用set作为前缀，之后接要更改的属性的名称，属性名的第一个字母要求大写。
Cocoa的OC直接使用属性名作为方法名，作为getter方法。

为什么不允许直接方位成员属性，而要通过 getter和setter方法来完成操作呢？
一切都是为了封装。类中包含哪些实例变量以及怎么使用这些实例变量都和类的实现紧密相关。而如果运行直接访问了类的实例变量，那么当类的实现发生了变化，实例变量被删除或者作用发生了变化时，所有调用这个类的外部模块都需要更改。
而如果使用了getter/setter的形式，那么当类的实现发生了变化时，则只需要更改getter/setter接口

同样的道理，父类和子类之间也要尽可能地多利用getter/setter方法。

* 实例变量的可变性
虽然一般情况下不允许从国外部直接访问对象的实例变量，但如果一定要访问的话，也可以通过其他办法来访问。
能否从外部访问实例变量决定了访问的可见性。OC中有四种可见性修饰符。
    * @private
    * @protected
    * @public
    * @package

* 在实现部分中定义实例变量
允许在实现部分中定义类的实例变量。
让一个变量对外不可见有两种方法，一种是吧变量的可见性属性设为@private,另一种就是把变量的定义在实行文件中。相比之下第二种方法封装性更好一点，同事你也可以清楚地表明这些变量对外是不可见的。

## 类对象

* 什么是类对象
面向对象的语言中对类有两种认识，一种是认为类只作为类型的定义，程序运行时不作为实体存在；另外一种是认为类本身也作为一个对象存在。后面一种对象叫作类对象。

类对象有自己的方法和变量，分别被称为类方法和类变量。

OC中只有类方法的概念，没有类变量的概念。

通过向类发送消息可以生产实例对象，那么类对象自身是什么时候生产的呢？类对象是程序执行时自动生成的，每个类只有一个类对象，不需要手动生成。

* 类对象的类型
id类型可以表示任何对象，类对象也可以用于id类型来表示。OC中还专门定义了一个Class类型用来表示类对象，所有类对象都是Class类型。Class和id一样都是指针类型，只是一个地址，并不需要了解实际指向的内容。Nil被用来表示空指针。

将类名定义为消息接收者是类对象特有的功能，除此之外类名只能在类型定义时使用。

* 类方法的定义
实例方法在接口声明和实现文件中都以 - 开头，类方法则与此相反，以 + 开头。

* 类变量
OC不支持类变量。
OC通过实现文件中定义静态变量的方法来代替类变量。
OC在现实文件中定义了静态变量后，该变量的作用域就变为只在该文件内有效。只有在类的类方法和实例方法可以访问这个变量。
static 变量的作用域仅限于定义它的文件内，所以子类无法访问父类中定义的static变量。
可以通过定义类方法来解决这个问题。

* 类对象的初始化

OC中实例对象的生成一般分为两步，第一步是通过alloc为对象分配内存，第二步是对内存进行初始化，也就是对对象的各个成员赋予初值。

* 初始化方法的返回值
初始化的方法返回值都应该设为id类型。
在继承存在的情况下，尽可能地避免使用静态类型吧代码写死。


# 基于引用计数的内存管理

## 动态内存管理
* 内存管理的必要性
如果程序没能妥善管理内存，运行过程中就不能但不能释放不再使用的内存，而且还会不停地分配内存， 这样所占用的内存就会越来越多，程序速度也会越来越慢，最后甚至会因为内存耗尽而奔溃。

就好像漏水一样，程序未能释放的内存已经不再使用的内存叫作内存泄漏。
如果访问了已经被释放的内存，则会造成数据错误，严重时甚至会导出程序异常中止。在指针所指向的对象已经被释放或收回的情况下，该指针就称为悬垂指针或野指针。继续使用这种指针会造成程序崩溃。

OC会通过向类对象发送alloc消息生成实例对象，alloc的作用就是分配内存。alloc方法返回的值是id类型，id是指针类型，指向的是为实例对象分配的内存。生成的实例对象用完之后不被释放的话，就会发生内存泄漏。如果给已经释放了的实例对象发送信息，可能会造成程序错误甚至异常终止。OC的程序中一定要注意内存管理。

在面向对象的语言中，对象是程序的核心。而对象也有生命周期，既有从头到尾一直存在的对象，也有生命短暂的临时对象。对象之间也有可能互相引用，构成结构复杂的数据结构。

* 引用计数、自动引用计数和自动垃圾回收
Cocoa的OC提供了一种动态的内存管理方式，称为引用计数。这种方式会跟踪每个对象引用的次数，当对象的引用次数为0时，系统就会释放这个对象所占用的内存。  -- 基于引用计数的内存管理

比引用计数内存管理更高级一点的就是自动引用计数 ARC，自动引用计数使开发者不需要考虑何时该使用 retain、release、autorelease 来管理内存，他提供了自动评估对象生存期的功能，在编译期间会自动加入合适的管理内存的方法。

除了ARC外，OC还提供自动内存管理机制--垃圾回收。使用垃圾回收时，就不在需要通过引用计数来管理创建的对象，系统会自动识别哪些对象仍然使用、哪些对象可以回收。

ARC 自动引用计数使一个编译技术，利用此计数可以简化OC在内存管理方面的工作量。


* ARC 的基本注意事项
    * 不能在程序中定义和使用下面这些函数：retain、release、autorelease和retainCount
    * 使用 @autoreleasepool 代替 NSAutoreleasePool
    * 方法命名必须遵循命名规则，不能随意定义以alloc/ini/new/copy/mutableCopy开头且和所有权操作无关的方法
    * 不用 dealloc 中释放实例变量，也不需要调用 [super dealoc]
    * 编译代码时使用编译器 clang，并加上编译选项 -fobjc-arc

## 循环引用和弱引用
* 循环引用
多个对象之间相互引用，容易产生循环引用的问题。

* 弱引用
弱引用是存储一个指向对象的指针，且不保留对象。 __weak

* 自动nil化的弱引用
在ARC条件下，最需要注意的就是不要形成循环引用。通过使用弱引用既可以防止生成循环引用，又可以防止对象呗释放后形成野指针。
由于ARC中只有强引用才能改变对象的引用计数，保持住对象，因此。如果想保持某对象，至少要为其赋值一个强引用类型的变量。

* 对象之间引用关系的基本原则
尽量保证对象之间的关系呈树形结构，避免一个对象同时被两处引用。


## ARC 编程时其他一些注意事项

* 可以像通常的指针一样使用对象
使用ARC的时候，如果既不想保持赋值的对象，也不想赋值的对象在释放后被自动设为nil，可以使用生命周期修饰符 __unsafe_unretained。 __unsafe_unretained所修饰的变量称为非nil化的弱指针。也就是说，如果所指向的内存区域被释放了，这个指针就是一个野指针。

* setter方法的注意事项
有一种减少野指针出现的方法，当不再使用传入的对象是，将其赋值为nil。
在dealloc方法中进行。

* 通过函数的参数返回结果对象
当一个函数或方法有多个返回值时，我们可以铜鼓偶函数或方法的参数传入一个指针，将返回值写入指针所指向的空间。C语言中吧这种方法叫做按引用传递。OC ARC中也有类似的方法，但采用了和C语言不通的实现方式，叫做写回传。
写回传经常被用于当一个方法在处理过程中出现错误时，通过指向NSError的二重指针返回错误的种类和原因。



# 垃圾回收
iOS 目前不能用


# 属性声明
OC支持简洁代码来调用访问方法，也允许自动生成访问方法。通过这些方便的功能，即使不手动实现访问方法，也能够操作对象的属性值。

## 属性是什么
* 使用属性编程
属性指的是一个对象的属性或特性

属性声明的一些规则总结：
    * 自动生成访问方法
    * 自动生成实例变量
    * 更简单地调用访问方法
    * 属性的内省

* 属性的概念
OC中引入了属性声明和使用点操作符来调用访问方法的手法。使用属性声明可以更简洁地实现访问方法。另一方面，不仅仅是访问方法，KVC中所有定义的实例变量都可以被当做属性处理。

## 属性的声明和功能
* 显示声明属性
@property是编译器指令，后面是属性的类型与，名称

属性声明等同于声明了读写两个访问方法。
属性声明的时候还可以为属性自定义选项。


* 属性的实现

* @synthesize和实例变量

* 通过 @synthesize生成实例变量

* 给属性指定选项
    * 指定方法名 getter/setter
    * 读写属性 readonly/readwrite
    * 赋值时的选项 assign/retain/unsafe_unretained/strong/weak/copy
    * 原子性操作 nonatomic

* 赋值时的选项

1. @property的属性不是对象类型
2. @property的属性是对象类型，且手动管理内存
3. 属性是对象类型，且使用ARC管理内存
4. 属性是对象类型，且使用垃圾回收管理内存

*  原子性
nonatomic表示访问方式是非原子性的。原子性是多线程中的一个概念，如果说访问方法是原子的，那就意味着多线程环境下访问属性是安全的，在执行的过程中不可被打断。
如果在多个线程中同事调用getter或setter，就有可能出现值丢失或内存泄漏等错误。通过使用lock和unlock，能够保证每次最多有一个线程执行lock和unlock之间的代码，从而也就保证了原子性。

* 属性声明和继承
子类中可以使用父类中定义的属性，也可以重写父类中定义的访问方法。但是，父类中属性声明时指定的各种属性，或者为实例变量指定的getter和setter的名称等必须完全一样。
唯一一个特别的情况是，对于父类中被定义为readonly类型的属性，子类中可以将其表位readwrite。

* 方法族和属性的关系
使用ARC的时候，必须注意方法的命名，不要和方法族发生冲突。
属性声明的时候会默认生成和属性同名的getter访问方法，需要注意属性名是否和方法族名冲突。特别要注意以new开头的属性名的情况。

## 通过点操作符访问属性

* 点操作符的使用方法
点操作符只能用于类类型的实例变量，不能对id类型的变量应用点操作符。


# 基类NSObject和运行时系统

## 类NSObject

* 根类的作用

* 类和实例
NSObject 只有一个实例变量，就是Class类型的变量isa。
isa用于标识实例对象属于哪个类对象。因为isa决定着实例变量和类的关系，所以自雷不可修改isa的值。也不能通过直接访问isa来查询实例变量到底属于哪个类，而要通过实例方法class来完成查询。
NSObject的方法与其说是为自己定义的，不如说是为其子类和所有的实例对象儿定义的。

* 实例对象的生成和释放

* 初始化

* 对象的比较
原则上来讲，具有相同id值也就是同一个指针指向的对象会被认为是相等的。而子类在这个基础上又进行了扩展，把拥有相同值认为是相等。
散列值相等的两个对象不一定相等。

* 对象的内容描述

## 消息发送机制

* 选择器和SEL类型
OC为了能够在程序中操作编译后的选择器，定义了@selector()指令。通过使用@selector()指令，就可以直接引用编译后的选择器。

* 消息搜索
对象收到一个消息后会执行哪个方法是动态决定的。
所有的实例变量都存在一个Class类型的isa变量，他就是类对象。当收到消息后，运行时系统会检查类内是否有和这个消息选择器相同的方法，如果有就执行对应的方法， 如果没有就通过类对象指向父类的指针来查找父类中是否有对应的方法。如果一直没有找到对应的方法，就会提示执行时错误。
如果每次收到消息都会查找相应的方法的话，消息发送过程的开销就会很大。针对这种情况，运行时系统内部会缓存一个散列表，表中记录着某个类拥有和什么样的选择器对应的方法、方法被定义的何处等信息。

NSObject中定义了可以动态查询一个对象是否能够响应某个选择器的方法。

* 以函数的形式来调用方法

* 对self进行赋值
在定义初始化方法是，用父类初始化方法的返回值对self进行赋值并判断其不为nil是一种更安全的做法。

* 发送消息的速度
发送消息比调用函数要慢。

* 类对象和根类
类对象是一个对象，类对象可以作为根类NSObject的某个子类的对象来使用。
类对象的类的对象是存在的。类对象的类被叫做元类。实例对象所属的类是class，类对象所属的类是metaclass。
现在OC中已经不存在元类的概念了，程序中也不能操作元类。

类对象中保存的是实例对象，元类对象找那个保存的是类方法。通过这样的定义能够统一实现实例方法和类方法的调用机制。
类对象可以执行根类对象的实例方法。


* Target-action paradigm
目标动作模式

```Objective-C
@interface myCell : NSObject
{
    SEL action;
    id target
}
- (void)setAction:(SEL)aSelector;
- (void)setTarget:(id)anObject;
- (void)performClick:(id)sender;
@end
@implementation myCell

- (void)setAction:(SEL)aSelector
{
    action = aSelector;
}

- (void)setTarget:(id)anObject
{
    target = anObject
}

- (void)performClick:(id)sender
{
    (void)[target performSelector:action withObject:sender];
}

@end
```

# Foundation

## 对象的可变性

* 可变对象 和不可变对象

OC中的类分为可变类和不可变类。可变类的实例对象称为可变对象，指的是创建后能够改变其内容和状态的对象。不可变的实例对象称为不可变对象，指的是创建后不可更改其内容的对象。对象是否可变的属性称为可变性。

不可变对象的概念在并行编程中很重要。因为可变对象的值可能会在不知不觉中被其他线程所修改。

* 可变对象的生成
给不可变对象发送mutableCopy消息的话，会生成一个和不可变对象一致的可变对象。

## 字符串类NSString
* 常量字符串
字符串常量从程序的执行开始到终止一直存在。
* NSString
* NSMutableString

## NSData
NSData是Cocoa下对二进制数据的一个封装，能够把二进制数据当做对象来处理。
NSData是不可变的，所以实例对象一旦创建之后就不可改变其内容。二如果想改变数据的内容的话，就需要使用将在后面介绍的类NSMutableData。

## 数组类
* NSArray
* NSMutableArray
* 数组对象的所有权
* 快速枚举
* 枚举器NSEnumerator
* 快速枚举和枚举器
* 集合类


## 词典类
Cocoa Foundation 框架中提供了一种和Map相类似的数据结构，叫作词典。词典也分为不可变词典NSDictionary和可变词典NSMutableDictionary。

* NSDictionary
类NSDictionary是不可变的词典类，一旦创建之后就只能查询，不可再增加、删除或修改其中的内容。

* NSMutableDictionary

## 包裹类
* NSNumber
* NSValue
* 类型编码和@encode()
* NSNull

## NSURL
* 关于URL
* 使用NSURL来访问资源



# 分类

## 分类
* 分类
* 分类和文件的组织
* 作为子模块的分类
* 方法的前向声明
* 私有方法
* 类扩展

* 分类和属性声明

## 给现用类追加分类
* 追加新的方法
* 覆盖已有的方法


## 关联引用
* 关联引用的概念
通过分类可以为一个类追加新的方法，但不能追加实例变量。但是，利用OC语言的动态性，并借助runtime的功能，就可以为已存在的实例对象增加实例变量，这个功能叫作关联引用。将这个功能和分类组合在一起使用，及时不创建子类，也能够对类进行动态扩展。
在类定义中，该类的所有实例都能够使用接口中声明的实例变量。

* 添加和检索关联
```Objective-C
void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)
id objc_getAssociatedObject(id object, void *key)
```

* 对象的存储方式
policy的值有以下几种可供选择：
    * OBJC_ASSOCIATION_ASSIGN
    * OBJC_ASSOCIATION_RETAIN_NONATOMIC
    * OBJC_ASSOCIATION_RETAIN
    * OBJC_ASSOCIATION_COPY_NONATOMIC
    * OBJC_ASSOCIATION_COPY

* 断开关联
```Objective-C
void objc-remvoeAssociatedObjects(id object)
```


# 抽象类和类簇
抽象类自身不生成实例，它是为了给所有继承他的子类提供统一的接口而定义的。


# 协议 
协议就是声明方法的集合，他表示对象的行为。协议与具体实现无关，它是根据消息来获取对象的一套系统化的方法。

## 协议的概念
* 什么是协议
* 对象的协议

## OC中协议的声明
* 协议的声明
* 协议的采用
* 协议的继承
* 指定协议的类型的声明
* 协议的前置声明
* 协议适用性检查
* 必选功能和可选功能

## 非正式协议
* 什么是非正式协议
    * 非正式协议被声明为NSObject类的分类
    * 非正式协议中声明的方法不一定要实现
    * 编译时，不能检查类对非正式协议的适用性
    * 运行时，不能检查类对非正式协议的适用性。只能确认是否实现了每个方法

* 非正式协议的用途


# 对象的复制及存储

## 对象的复制
* 浅复制和深复制
用与一个实例对象相同的内容，生成一个新对象，这个过程一般称为复制。其中，只复制对象的指针称为浅复制，而复制具有新的内存空间的对象则称为深复制。

* 区域
Cocoa中一直把动态分配的内存管理称为区域。
动态分配内存的堆区域使用了地址空间中很大一片区域。

* 复制方法的定义

## 归档
* 对象的归档
将对象存储转换为二进制序列的过程称为归档、打包或编码，逆变换则称为解档。

## 属性表




# 块对象

## 什么是块对象
块对象是Block，与闭包功能基本相同。

* 块对象的定义
块指针或闭包是什么？
```Objective-C
^(参数列){主体}
```

这里，从"^"开始到参数列、主体最后的大括号，这一段记述称为块对象的块句法。
块对象本省常用于带入到变量后评估，或被作为函数或方法的参数传入等。

* 块对象和类型声明
同函数指针一样，为了简化类型的书写，我们也可以使用typedef简化声明。
```Objective-C
typedef int (^myBlockType)(int);
```
使用该类型后，声明函数func就可以使用下面的定义。
```Objective-C
void func(myBlockType block)
```

* 块对象中的变量行为


## 换对象的构成

* 块对象的实例和生命周期
1. 块句法卸载函数外面时，只在静态数据区分配一片内存区域给块对象。这片区域在程序执行期会一直存在。
2. 块句法写在函数内是，和自动变量一样，块对象的内存区域会在执行包含块对象的函数时被保存在栈上。

* 块对象的复制
函数内的块对象和自动变量相同，生命周期只在函数执行期间。

* 指定特殊的变量 __block
块对象可以包含器访问的自动变量的副本，但是只能直接读取值。若要在多个块多个块对象之间共享可以读写的值，就只能利用外部变量或静态变量。

修饰符`__block`修饰的变量有如下功能：
1. 函数内块句法引用的`__block`变量是块对象可以读取的变量。同一个变量作用域内有多个块对象访问时，他们之间可以共享`__block`变量值。
2. `__block`变量不是静态变量，它在块句法每次执行块句法时获取变量的内存区域。也就是说，同一个块内的块对象及它们间共享的`__block`变量实在执行时动态生成的。
3. 访问`__block`变量的块对象在被复制后，新生成的块对象也能共享`__block`变量的值。
4. 多个块对象访问同一个`__block`变量是，只要有一个块对象存在着，`__block`变量就会随之存在。如果访问`__block`变量的块对象都不存在了，`__block`对象也会随之消息。

需要注意的是，随着块对象的复制，__block变量的内存位置有时会发生变化。而且，大家不要写试用指针来引用`__block`变量的代码。


## OC和块对象
* 方法定义和块对象
* 作为OC对象的块对象
块对象会成为OC的对象来执行操作
* ARC和块对象
在ARC中需要保持块对象时，编译器会自动插入copy操作
* 对象内变量的行为

块对象和对象的关系可总结如下：
1. 方法定义内的块句法中存在实例变量时，可以直接访问实例变量，也可以改变其值。
2. 方法定义内的块句法中存在实例变量时，如果在栈上生成块对象的副本，retain就会发送给self而非实例变量，引用计数器的值也会加1.实例变量的类型不一定非得是对象。
3. 块句法内存在非实例变量的对象时，如果在栈上生成某个块对象的副本，包含的对象就会接受到retain，引用计数器的值不变。
4. 已经复制后，堆区域中某个块对象即使收到copy方法，结果也只是块对象自身的引用计数器加1.包含的对象的引用计数器的值不变。
5. 复制的块对象在被释放时，也会向包含的对象发送release.


# 消息发送模式


# 应用的构造



# 异常和错误


# 并行编程



# 键值编码



